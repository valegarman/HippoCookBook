
function coactivation_metrics = compute_coactivation_metrics(uLEDcoactivation, varargin)
% coactivation_metrics = compute_coactivation_metrics(uLEDcoactivation, varargin)
% Compute some metrics from coactivation experiments MV 2025
%
% Parse options
p = inputParser;
addRequired(p,'uLEDcoactivation');
addParameter(p,'basepath',pwd,@ischar);
addParameter(p,'saveMat',false,@islogical);
addParameter(p,'force',false,@islogical);
addParameter(p,'save_as','coactivation_metrics',@ischar);
addParameter(p,'include_units', 'all'); % possible values: binary vector, 'pyramidal cells', 'all' (default),
% 'distinct shank', 'distinct_electrode', 'pyramidal cells distinct shank',
% 'pyramidal cells distinct electrode'
addParameter(p,'clipping_threshold',3,@isnumeric);
addParameter(p,'do_plot',true,@islogical);

parse(p, uLEDcoactivation, varargin{:});
basepath = p.Results.basepath;
saveMat = p.Results.saveMat;
force = p.Results.force;
save_as = p.Results.save_as;
include_units = p.Results.include_units;
clipping_threshold = p.Results.clipping_threshold;
do_plot = p.Results.do_plot;

% Deal with inputs
prevPath = pwd;
cd(basepath);

targetFile = dir('*.coactivation_metrics.cellinfo.mat');
if ~isempty(targetFile) && ~force
    disp('Coactivation metrics already computed! Loading file...');
    load(targetFile.name);
    return
end

if isnumeric(include_units)
    coact = uLEDcoactivation.pairwise.coactZ;
    pre = uLEDcoactivation.pairwise.preZ;
    post = uLEDcoactivation.pairwise.postZ;
    
    coact(~include_units,:) = NaN; coact(:, ~include_units) = NaN;
    pre(~include_units,:) = NaN; pre(:, ~include_units) = NaN;
    post(~include_units,:) = NaN; post(:, ~include_units) = NaN;

elseif ischar(include_units)
    switch lower(include_units)
        case 'all'
            coact = uLEDcoactivation.pairwise.coactZ;
            pre = uLEDcoactivation.pairwise.preZ;
            post = uLEDcoactivation.pairwise.postZ;
        case 'pyramidal cells'
            coact = uLEDcoactivation.pairwise_pyramidalCells.coactZ;
            pre = uLEDcoactivation.pairwise_pyramidalCells.preZ;
            post = uLEDcoactivation.pairwise_pyramidalCells.postZ;
        case 'distinct shank'
            coact = uLEDcoactivation.pairwise_distinct_shank.coactZ;
            pre = uLEDcoactivation.pairwise_distinct_shank.preZ;
            post = uLEDcoactivation.pairwise_distinct_shank.postZ;
        case 'distinct electrode'
            coact = uLEDcoactivation.pairwise_distinct_electrode.coactZ;
            pre = uLEDcoactivation.pairwise_distinct_electrode.preZ;
            post = uLEDcoactivation.pairwise_distinct_electrode.postZ;
        case 'pyramidal cells distinct shank'
            coact = uLEDcoactivation.pairwise_pyramidalCells_distinct_shank.coactZ;
            pre = uLEDcoactivation.pairwise_pyramidalCells_distinct_shank.preZ;
            post = uLEDcoactivation.pairwise_pyramidalCells_distinct_shank.postZ;
        case 'pyramidal cells distinct electrode'
            coact = uLEDcoactivation.pairwise_pyramidalCells_distinct_electrode.coactZ;
            pre = uLEDcoactivation.pairwise_pyramidalCells_distinct_electrode.preZ;
            post = uLEDcoactivation.pairwise_pyramidalCells_distinct_electrode.postZ;
    end
end

%% 1 % CLUSTERING RESPONSES
% 1.1 % Remove bad rows/cols
\to_remove = all(isnan(coact), 2);  % 
valid_units = ~to_remove;
Z = coact(valid_units, valid_units);
preZ = pre(valid_units, valid_units);
postZ = post(valid_units, valid_units);

% 1.2 % Clip extreme Z-scores
Z_clipped = max(min(Z, clipping_threshold), -clipping_threshold);
preZ_clipped = max(min(preZ, clipping_threshold), -clipping_threshold);
postZ_clipped = max(min(postZ, clipping_threshold), -clipping_threshold);

% Remove diagonal
Z_clipped(logical(eye(size(Z_clipped)))) = 0;
preZ_clipped(logical(eye(size(preZ_clipped)))) = 0;
postZ_clipped(logical(eye(size(postZ_clipped)))) = 0;

% 1.3 % Signed modularity clustering
% Modularity (Q) measures how well a network is divided into clusters:
% higher Q means stronger within-cluster connectivity vs. random expectation.
% Typical: Q > 0.3 = modular structure; Q > 0.5 = strong community structure.

rng(1);  % any number 
[Ci, Q] = community_louvain(Z_clipped, 1.1, [], 'negative_asym'); 
cluster_stim = Ci;
[cluster_pre, Q_pre] = community_louvain(preZ_clipped, 1.1, [], 'negative_asym');
[cluster_post, Q_post] = community_louvain(postZ_clipped, 1.1, [], 'negative_asym');

Q_pre_by_stim = modularity_signed(preZ_clipped, Ci);
Q_post_by_stim = modularity_signed(postZ_clipped, Ci);

fprintf('Modularity (Q) - Pre: %.3f | Stim: %.3f | Post: %.3f\n', Q_pre_by_stim, Q, Q_post_by_stim);

% 1.4 % Assortability
% Assortativity measures whether nodes preferentially connect to others in the same group.
% Positive = within-group connections; negative = between-group preference; zero = random.
r_pre = assortativity_by_cluster(preZ_clipped, Ci);
r_stim = assortativity_by_cluster(Z_clipped, Ci);
r_post = assortativity_by_cluster(postZ_clipped, Ci);

fprintf('Assortability by cluster - Pre: %.3f | Stim: %.3f | Post: %.3f\n', r_pre, r_stim, r_post);

% save values
coactivation_metrics.community_louvain.Q_pre = Q_pre;
coactivation_metrics.community_louvain.Q_stim = Q;
coactivation_metrics.community_louvain.Q_post = Q_post;

coactivation_metrics.community_louvain.Q_pre_by_stim = Q_pre_by_stim;
coactivation_metrics.community_louvain.Q_post_by_stim = Q_post_by_stim;

coactivation_metrics.community_louvain.cluster_stim = cluster_stim;
coactivation_metrics.community_louvain.cluster_pre = cluster_pre;
coactivation_metrics.community_louvain.cluster_post = cluster_post;

coactivation_metrics.assortability.r_pre = r_pre;
coactivation_metrics.assortability.r_stim = r_stim;
coactivation_metrics.assortability.r_post = r_post;

if do_plot
    % stim clusters
    caxis_lim = 2;
    figure
    subplot(3,3,5)
    [~, perm] = sort(Ci);
    sorted_matrix = Z_clipped(perm, perm);
    sorted_Ci = Ci(perm);
    imagesc(sorted_matrix); colormap('parula'); colorbar;
    caxis([-caxis_lim caxis_lim]);
    hold on;
    b = find(diff(sorted_Ci) ~= 0) + 0.5;
    for x = b; xline(x,'k','LineWidth',1.5); yline(x,'k','LineWidth',1.5); end
    title({['Stim'], ['Q = ' num2str(Q,2) ', r = ' num2str(r_stim,2)]});
    hold off;
    axis square
    
    subplot(3,3,4)
    sorted_matrix = preZ_clipped(perm, perm);
    imagesc(sorted_matrix); colormap('parula'); colorbar;
    caxis([-caxis_lim caxis_lim]);
    hold on;
    b = find(diff(sorted_Ci) ~= 0) + 0.5;
    for x = b; xline(x,'k','LineWidth',1.5); yline(x,'k','LineWidth',1.5); end
    hold off;
    title({['Pre'], ['Q = ' num2str(Q_pre_by_stim,2) ', r = ' num2str(r_pre,2)]});
    ylabel('Clustering by Stim', 'FontWeight','bold');
    axis square
    
    subplot(3,3,6)
    sorted_matrix = postZ_clipped(perm, perm);
    imagesc(sorted_matrix); colormap('parula'); colorbar;
    caxis([-caxis_lim caxis_lim]);
    hold on;
    b = find(diff(sorted_Ci) ~= 0) + 0.5;
    for x = b; xline(x,'k','LineWidth',1.5); yline(x,'k','LineWidth',1.5); end
    hold off;
    title({['Post'], ['Q = ' num2str(Q_post_by_stim,2) ', r = ' num2str(r_post,2)]});
    axis square
    
    % pre clusters
    caxis_lim = 2;
    subplot(3,3,2)
    [~, perm] = sort(cluster_pre);
    sorted_matrix = Z_clipped(perm, perm);
    sorted_Ci = cluster_pre(perm);
    imagesc(sorted_matrix); colormap('parula'); colorbar;
    caxis([-caxis_lim caxis_lim]);
    hold on;
    b = find(diff(sorted_Ci) ~= 0) + 0.5;
    for x = b; xline(x,'k','LineWidth',1.5); yline(x,'k','LineWidth',1.5); end
    hold off;
    title({['Stim']});
    axis square
    
    subplot(3,3,1)
    sorted_matrix = preZ_clipped(perm, perm);
    imagesc(sorted_matrix); colormap('parula'); colorbar;
    caxis([-caxis_lim caxis_lim]);
    hold on;
    b = find(diff(sorted_Ci) ~= 0) + 0.5;
    for x = b; xline(x,'k','LineWidth',1.5); yline(x,'k','LineWidth',1.5); end
    hold off;
    title({['Pre'], ['Q = ' num2str(Q_pre,2)]});
    ylabel('Clustering by Pre', 'FontWeight','bold');
    axis square
    
    subplot(3,3,3)
    sorted_matrix = postZ_clipped(perm, perm);
    imagesc(sorted_matrix); colormap('parula'); colorbar;
    caxis([-caxis_lim caxis_lim]);
    hold on;
    b = find(diff(sorted_Ci) ~= 0) + 0.5;
    for x = b; xline(x,'k','LineWidth',1.5); yline(x,'k','LineWidth',1.5); end
    hold off;
    title({['Post']});
    axis square

    % post clusters
    caxis_lim = 2;
    subplot(3,3,8)
    [~, perm] = sort(cluster_post);
    sorted_matrix = Z_clipped(perm, perm);
    sorted_Ci = cluster_post(perm);
    imagesc(sorted_matrix); colormap('parula'); colorbar;
    caxis([-caxis_lim caxis_lim]);
    hold on;
    b = find(diff(sorted_Ci) ~= 0) + 0.5;
    for x = b; xline(x,'k','LineWidth',1.5); yline(x,'k','LineWidth',1.5); end
    hold off;
    title({['Stim']});
    xlabel('# Neurons');
    axis square
    
    subplot(3,3,7)
    sorted_matrix = preZ_clipped(perm, perm);
    imagesc(sorted_matrix); colormap('parula'); colorbar;
    caxis([-caxis_lim caxis_lim]);
    hold on;
    b = find(diff(sorted_Ci) ~= 0) + 0.5;
    for x = b; xline(x,'k','LineWidth',1.5); yline(x,'k','LineWidth',1.5); end
    hold off;
    title({['Pre']});
    ylabel('Clustering by Post', 'FontWeight','bold');
    axis square
    
    subplot(3,3,9)
    sorted_matrix = postZ_clipped(perm, perm);
    imagesc(sorted_matrix); colormap('parula'); colorbar;
    caxis([-caxis_lim caxis_lim]);
    hold on;
    b = find(diff(sorted_Ci) ~= 0) + 0.5;
    for x = b; xline(x,'k','LineWidth',1.5); yline(x,'k','LineWidth',1.5); end
    hold off;
    title({['Post'], ['Q = ' num2str(Q_post,2)]});
    axis square

    mkdir('SummaryFigures');
    exportgraphics(gcf,['SummaryFigures\' save_as '_louvain_clusters.png']);
end


%% 2 % COMPARING PARTITIONS BY RAND INDEX
% Adjusted Rand Index (ARI) quantifies similarity between two clusterings.
% ARI = 1: perfect match; ARI = 0: random agreement; ARI < 0: worse than chance.
% Used here to compare artificial labels with Louvain clustering.
artificial_clusters = uLEDcoactivation.clusters.artificial_clusters;
validIdx = ~isnan(artificial_clusters) & artificial_clusters ~= 0;
true_labels  = artificial_clusters(validIdx);
pre_labels   = cluster_pre(validIdx);
stim_labels  = cluster_stim(validIdx);
post_labels  = cluster_post(validIdx);

ari_pre  = adjusted_rand_index(true_labels, pre_labels);
ari_stim = adjusted_rand_index(true_labels, stim_labels);
ari_post = adjusted_rand_index(true_labels, post_labels);
ari_pre_post = adjusted_rand_index(pre_labels, post_labels);
ari_pre_stim = adjusted_rand_index(pre_labels, stim_labels);
ari_post_stim = adjusted_rand_index(post_labels, stim_labels);

fprintf('ARI - Pre: %.3f | Stim: %.3f | Post: %.3f\n', ari_pre, ari_stim, ari_post);
fprintf('ARI - Pre-Post: %.3f | Pre-Stim: %.3f | Post-Stim: %.3f\n', ari_pre_post, ari_pre_stim, ari_post_stim);

nShuffles = 10000;
ari_shuff_stim = zeros(nShuffles,1);
ari_shuff_pre = zeros(nShuffles,1);
ari_shuff_post = zeros(nShuffles,1);
ari_shuff_pre_post = zeros(nShuffles,1);
ari_shuff_pre_stim = zeros(nShuffles,1);
ari_shuff_post_stim = zeros(nShuffles,1);

for i = 1:nShuffles
    shuffled = true_labels(randperm(length(true_labels)));
    ari_shuff_stim(i) = adjusted_rand_index(shuffled, stim_labels);
    ari_shuff_pre(i) = adjusted_rand_index(shuffled, pre_labels);
    ari_shuff_post(i) = adjusted_rand_index(shuffled, post_labels);
    %
    ari_shuff_pre_post(i) = adjusted_rand_index(shuffled, post_labels);
    ari_shuff_pre_stim(i) = adjusted_rand_index(shuffled, pre_labels);
    ari_shuff_post_stim(i) = adjusted_rand_index(shuffled, post_labels);
end

real_ari = [ari_pre, ari_stim, ari_post, ari_pre_post, ari_pre_stim, ari_post_stim];
shuffled_ari = {ari_shuff_pre, ari_shuff_stim, ari_shuff_post, ari_shuff_pre_post, ari_shuff_pre_stim, ari_shuff_post_stim};
labels = {'Pre', 'Stim', 'Post', 'Pre-Post', 'Pre-Stim', 'Stim-Post'};

% Zscore and p-value
z_scores = zeros(1,3);
p_vals = zeros(1,3);

for i = 1:6
    mu = mean(shuffled_ari{i});
    sigma = std(shuffled_ari{i});
    z_scores(i) = (real_ari(i) - mu) / sigma;
    p_vals(i) = mean(shuffled_ari{i} >= real_ari(i));  % unilateral (efecto positivo)
end

% save values
coactivation_metrics.artificial_clusters = artificial_clusters;
coactivation_metrics.adjusted_rand_index.ari_pre = ari_pre;
coactivation_metrics.adjusted_rand_index.ari_stim = ari_stim;
coactivation_metrics.adjusted_rand_index.ari_post = ari_post;
coactivation_metrics.adjusted_rand_index.ari_pre_post = ari_pre_post;
coactivation_metrics.adjusted_rand_index.ari_pre_stim = ari_pre_stim;
coactivation_metrics.adjusted_rand_index.ari_stim_post = ari_post_stim;

coactivation_metrics.adjusted_rand_index.ari_pre_pval = p_vals(1);
coactivation_metrics.adjusted_rand_index.ari_stim_pval = p_vals(2);
coactivation_metrics.adjusted_rand_index.ari_post_pval = p_vals(3);
coactivation_metrics.adjusted_rand_index.ari_pre_post_pval = p_vals(4);
coactivation_metrics.adjusted_rand_index.ari_pre_stim_pval = p_vals(5);
coactivation_metrics.adjusted_rand_index.ari_stim_post_pval = p_vals(6);

coactivation_metrics.adjusted_rand_index.ari_pre_Z = z_scores(1);
coactivation_metrics.adjusted_rand_index.ari_stim_Z = z_scores(2);
coactivation_metrics.adjusted_rand_index.ari_post_Z = z_scores(3);
coactivation_metrics.adjusted_rand_index.ari_pre_post_Z = z_scores(4);
coactivation_metrics.adjusted_rand_index.ari_pre_stim_Z = z_scores(5);
coactivation_metrics.adjusted_rand_index.ari_stim_post_Z = z_scores(6);

if do_plot

    figure('Position', [300 300 800 600]);
    all_vals = cat(1, shuffled_ari{:}, real_ari(:));
    xlims = [floor(min(all_vals)*100)/100, ceil(max(all_vals)*100)/100];
    for i = 1:3
        subplot(3,3,i)
        histogram(shuffled_ari{i}, 40, 'FaceColor', [0.8 0.8 0.8], ...
                  'EdgeColor', 'none', 'Normalization', 'count');
        hold on
        xline(real_ari(i), 'r-', 'LineWidth', 2);
        xlim(xlims)
        title([labels{i}, '  —  Z = ', num2str(z_scores(i), '%.2f'), ...
               ',  p = ', num2str(p_vals(i), '%.3f')])
        if i == 1
            ylabel('Count')
        end
    end
    
    subplot(3,3,4:6)
    bar(z_scores, 'FaceColor', [0.5 0.7 0.9])
    set(gca, 'XTickLabel', labels, 'FontSize', 10)
    ylabel('Z-score (vs. shuffle)')
    ylim([0 max(z_scores)*1.2])
    title('Z-scores of Observed ARI')
    for i = 1:3
        text(i, z_scores(i)+0.05, ['p = ', num2str(p_vals(i), '%.3f')], ...
            'HorizontalAlignment', 'center', 'FontSize', 10)
    end
    sgtitle('Observed ARI vs. Shuffling');

    caxis_lim = 2;
    subplot(3,3,8)
    [~, perm] = sort(artificial_clusters);
    sorted_matrix = Z_clipped(perm, perm);
    sorted_Ci = artificial_clusters(perm);
    imagesc(sorted_matrix); colormap('parula'); colorbar;
    caxis([-caxis_lim caxis_lim]);
    hold on;
    b = find(diff(sorted_Ci) ~= 0) + 0.5;
    for x = b; xline(x,'k','LineWidth',1.5); yline(x,'k','LineWidth',1.5); end
    hold off;
    title({['Stim']});
    xlabel('# Neurons');
    axis square

    subplot(3,3,7)
    sorted_matrix = preZ_clipped(perm, perm);
    imagesc(sorted_matrix); colormap('parula'); colorbar;
    caxis([-caxis_lim caxis_lim]);
    hold on;
    b = find(diff(sorted_Ci) ~= 0) + 0.5;
    for x = b; xline(x,'k','LineWidth',1.5); yline(x,'k','LineWidth',1.5); end
    hold off;
    title({['Pre']});
    ylabel('Clustering by uLEDs groups', 'FontWeight','bold');
    axis square
    
    subplot(3,3,9)
    sorted_matrix = postZ_clipped(perm, perm);
    imagesc(sorted_matrix); colormap('parula'); colorbar;
    caxis([-caxis_lim caxis_lim]);
    hold on;
    b = find(diff(sorted_Ci) ~= 0) + 0.5;
    for x = b; xline(x,'k','LineWidth',1.5); yline(x,'k','LineWidth',1.5); end
    hold off;
    title({['Post']});
    axis square

    mkdir('SummaryFigures');
    exportgraphics(gcf,['SummaryFigures\' save_as '_adjusted_rand_index.png']);

    % Sankey diagrams
    output_name = ['sankey_comparison'];

    % Pre vs Artificial
    T1 = table(cluster_pre(:), artificial_clusters(:), 'VariableNames', {'Ci1', 'Ci2'});
    writetable(T1, 'sankey_pre.csv');
    
    % Stim vs Artificial
    T2 = table(cluster_stim(:), artificial_clusters(:), 'VariableNames', {'Ci1', 'Ci2'});
    writetable(T2, 'sankey_stim.csv');
    
    % Post vs Artificial
    T3 = table(cluster_post(:), artificial_clusters(:), 'VariableNames', {'Ci1', 'Ci2'});
    writetable(T3, 'sankey_post.csv');
    
    script_path = which('sankey_triple_plot.py');
    python_path = char(pyenv().Executable);
    command = ['"', python_path, '" "', script_path, '" ', output_name];
    system(command);

    img_path = fullfile('SummaryFigures', [output_name, '.png']);
    img = imread(img_path);
    fig = figure('Name', ['Sankey: ', output_name]);
    imshow(img);

    % Sankey multi step, pre, stim, post
    output_name = 'sankey_pre_stim_post';

    T = table(cluster_pre(:), cluster_stim(:), cluster_post(:), ...
              'VariableNames', {'Pre', 'Stim', 'Post'});
    writetable(T, 'multi_stage_clusters.csv');
    
    script_path = which('sankey_multistage_plot.py');
    python_path = char(pyenv().Executable);
    command = ['"', python_path, '" "', script_path, '" ', output_name];
    system(command);
    
    img_path = fullfile('SummaryFigures', [output_name, '.png']);
    img = imread(img_path);
    fig = figure('Name', ['Sankey: ', output_name]);
    imshow(img);

    % Sankey multi step, pre, artificial, post
    output_name = 'sankey_artificial_stim_post';

    T = table(cluster_pre(:), artificial_clusters(:), cluster_post(:), ...
              'VariableNames', {'Pre', 'Artificial', 'Post'});
    writetable(T, 'multi_stage_clusters.csv');
    
    script_path = which('sankey_multistage_plot.py');
    python_path = char(pyenv().Executable);
    command = ['"', python_path, '" "', script_path, '" ', output_name];
    system(command);
    
    img_path = fullfile('SummaryFigures', [output_name, '.png']);
    img = imread(img_path);
    fig = figure('Name', ['Sankey: ', output_name]);
    imshow(img);

end

%% 3. ESTIMATING NEURON CONTRIBUTIONS TO ARI
keyboard;
% 3.1 % Leave-One-Out ARI
C_all = [cluster_pre(:), cluster_stim(:), cluster_post(:)];
C_ref = artificial_clusters(:);

loo_ari = compute_loo_ari_all(C_all, C_ref);

pairwise_consistency = compute_pairwise_consistency_all(C_all, C_ref);

% include cell types
cellTypeClassifier

% to do, loo ari by pairs
% save values
coactivation_metrics.adjusted_rand_index.leave_one_out_test = loo_ari;
coactivation_metrics.adjusted_rand_index.pairwise_consistency = pairwise_consistency;

if do_plot
end

figure
imagesc(loo_ari.importance)
xticks(1:3)
xticklabels({'Pre', 'Stim', 'Post'})
colorbar
ylabel('Neuron #')
title('LOO-ARI impact per neuron and condition');




cd(prevPath);
end

function result = compute_loo_ari_all(C_all, C_ref)
% Compute LOO-ARI importance per neuron for multiple conditions.
%
% INPUTS:
%   - C_all: N x K matrix of clustering labels (e.g., pre, stim, post)
%   - C_ref: N x 1 vector of reference labels (e.g., artificial clustering)
%
% OUTPUT:
%   - result: struct with fields:
%       * importance: N x K raw LOO-ARI values
%       * importance_relative: N x K (relative to full ARI)
%       * importance_zscore: N x K z-scored values (per condition)
%       * ari_full: 1 x K vector of ARI values using all neurons
%
% Requires: rand_index_adjusted(C1, C2)

nNeurons = size(C_all, 1);
nConds = size(C_all, 2);

importance = zeros(nNeurons, nConds);
importance_relative = zeros(nNeurons, nConds);
importance_zscore = zeros(nNeurons, nConds);
ari_full = zeros(1, nConds);

for k = 1:nConds
    Ci1 = C_all(:,k);
    Ci2 = C_ref(:);
    
    ari_full(k) = adjusted_rand_index(Ci1, Ci2);
    
    for i = 1:nNeurons
        keep = true(nNeurons, 1);
        keep(i) = false;
        ari_reduced = adjusted_rand_index(Ci1(keep), Ci2(keep));
        importance(i,k) = ari_full(k) - ari_reduced;
    end
    
    % Relative importance (avoiding division by 0)
    if ari_full(k) ~= 0
        importance_relative(:,k) = importance(:,k) / ari_full(k);
    else
        importance_relative(:,k) = zeros(nNeurons,1);
    end
    
    % Z-score normalization
    mu = mean(importance(:,k));
    sigma = std(importance(:,k));
    if sigma ~= 0
        importance_zscore(:,k) = (importance(:,k) - mu) / sigma;
    else
        importance_zscore(:,k) = zeros(nNeurons,1);
    end
end

% Output struct
result.importance = importance;
result.importance_relative = importance_relative;
result.importance_zscore = importance_zscore;
result.ari_full = ari_full;

end

function pairwise_consistency = compute_pairwise_consistency_all(C_all, C_ref)
% Compute pairwise consistency between each clustering and a reference
% 
% INPUT:
%   - C_all: N x K matrix of clustering labels (e.g., Pre, Stim, Post)
%   - C_ref: N x 1 vector of reference clustering (e.g., artificial)
%
% OUTPUT:
%   - result.consistency: N x K matrix of normalized consistency scores
%   - result.raw: N x K matrix of raw counts of consistent pairs per neuron
%   - result.full_matrices: cell array of N x N agreement matrices per condition

nNeurons = size(C_all, 1);
nConds = size(C_all, 2);

consistency_raw = zeros(nNeurons, nConds);
consistency_norm = zeros(nNeurons, nConds);
agreement_matrices = cell(1, nConds);

for k = 1:nConds
    Ci1 = C_all(:,k);
    Ci2 = C_ref(:);
    
    pairwise_agreement = zeros(nNeurons);
    
    for i = 1:nNeurons
        for j = i+1:nNeurons
            same1 = Ci1(i) == Ci1(j);
            same2 = Ci2(i) == Ci2(j);
            agree = double(same1 == same2);
            pairwise_agreement(i,j) = agree;
            pairwise_agreement(j,i) = agree;
        end
    end
    
    agreement_matrices{k} = pairwise_agreement;
    consistency_raw(:,k) = sum(pairwise_agreement, 2);           % total number of consistent pairs per neuron
    consistency_norm(:,k) = consistency_raw(:,k) / (nNeurons-1); % normalized to [0,1]
end

% Output struct
pairwise_consistency.consistency = consistency_norm;
pairwise_consistency.raw = consistency_raw;
pairwise_consistency.full_matrices = agreement_matrices;

end
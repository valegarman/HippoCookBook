%% BatchScript_analysis_example
% place your code to run an analysis across all sessions for a given
% project

clear all; close all
targetProject= 'LightInInh';
targetBehavior = 'linear maze';

HCB_directory = what('HippoCookBook'); 


sessionsTable = readtable([HCB_directory.path filesep 'indexedSessions.csv']); % the variable is called allSessions

for ii = 56: length(sessionsTable.SessionName)
     %% Analysis general all over Camkii/32 animal
    if contains(sessionsTable.Project{ii}, targetProject) || strcmpi('all', targetProject)

        fprintf(' > %3.i/%3.i session \n',ii, length(sessionsTable.SessionName)); %\n
        cd(adapt_filesep([nas_path(sessionsTable.Location{ii}) filesep sessionsTable.Path{ii}]));

        % try
            %%% your code goes here...
            clear uLEDResponses_interval
            delete(gcp('nocreate'))
            spikes = loadSpikes;
            spikes_times = spikes.times;
            monosyn_inh_win = [0.001 0.021]; % 01to21
            monosyn_control_win = [-0.041 -0.021];

            for mm = 1:spikes.numcells
                disp(mm);
                uLEDResponses_interval{mm} = getuLEDResponse_intervals([spikes_times{mm} + monosyn_inh_win(1) spikes_times{mm} + monosyn_inh_win(2)],...
                    'saveMat', false,'numRep',500,'doPlot', false,'getRaster', false, 'verbose', false, 'boostraping_type','pulses');
                % uLEDResponses_control{mm} = getuLEDResponse_intervals([spikes_times{mm} + monosyn_control_win(1) spikes_times{mm} + monosyn_control_win(2)],...
                %     'saveMat', false,'numRep',500,'doPlot', false,'getRaster', false, 'verbose', false);
                % 
            end

            collision_metrics_1_21 = get_light_spike_CollisionMetrics(uLEDResponses_interval,'label','1msTo21ms','saveMat',true,'update_cell_metrics',false,'save_as','lightSpikeCollisions_randInt','rate_change_threshold',3, 'rand_analysis',true);
            % collision_metrics_control = get_light_spike_CollisionMetrics(uLEDResponses_control,'label','control','saveMat',true,'update_cell_metrics',true,'save_as','lightSpikeCollisions_control','rate_change_threshold',3);

            clear uLEDResponses_interval
            clear uLEDResponses_control
            close all;
        % catch
        %     warning('Analysis was not possible!');
        % end
    end
end






%% Analysis for pre and post synaptic changes

for ii = 57 :length(sessionsTable.SessionName)
    
    if contains(sessionsTable.Project{ii}, targetProject) && contains(sessionsTable.Behavior{ii},targetBehavior) || strcmpi('all', targetProject) 
        
        cd(adapt_filesep([nas_path(sessionsTable.Location{ii}) filesep sessionsTable.Path{ii}])); 
        session = loadSession;
        delete(gcp('nocreate'))
        spikes = loadSpikes;
        spikes_times = spikes.times;
        monosyn_inh_win = [0.001 0.021]; % 01to21

        for kk= 1:length(session.epochs) 
            if strcmp(session.epochs{kk}.behavioralParadigm,'Maze')
                pre_end = session.epochs{kk}.startTime;
                post_start = session.epochs{kk}.stopTime;
                pre_maze = [0 pre_end];
                post_maze = [post_start Inf];
            end
        end

        
           % for mm = 1:spikes.numcells
           %      disp(mm);
           % 
           %      % uLEDResponses_interval_pre{mm} = getuLEDResponse_intervals([spikes_times{mm} + monosyn_inh_win(1) spikes_times{mm} + monosyn_inh_win(2)],...
           %      %     'saveMat', false,'numRep',500,'doPlot', false,'getRaster', false, 'verbose', false,'restrict_to',pre_maze,'minNumberOfPulses',100);
           % 
           %      uLEDResponses_interval_post{mm} = getuLEDResponse_intervals([spikes_times{mm} + monosyn_inh_win(1) spikes_times{mm} + monosyn_inh_win(2)],...
           %          'saveMat', false,'numRep',500,'doPlot', false,'getRaster', false, 'verbose', false, 'minNumberOfPulses',100,'restrict_to',post_maze);
           %  end
            % 
            % collision_metrics_1_21_pre = get_light_spike_CollisionMetrics(uLEDResponses_interval_pre,'label','1msTo21ms_pre','saveMat',true,'update_cell_metrics',false,'save_as','lightSpikeCollisions_pre','rate_change_threshold',3);
            % clear uLEDResponses_interval_pre
            % 
            % collision_metrics_1_21_post = get_light_spike_CollisionMetrics(uLEDResponses_interval_post,'label','1msTo21ms_post','saveMat',true,'update_cell_metrics',false,'save_as','lightSpikeCollisions_post','rate_change_threshold',3);
            % clear uLEDResponses_interval_post
            % %%%

            cell_metrics_before = ProcessCellMetrics('session', session,'restrictToIntervals',pre_maze,'forceReload',true,'saveAs','cell_metrics_before','getWaveformsFromDat',false,'manualAdjustMonoSyn',false); % after CellExplorar
            cell_metrics_after = ProcessCellMetrics('session', session,'restrictToIntervals',post_maze,'forceReload',true,'saveAs','cell_metrics_after','getWaveformsFromDat',false,'manualAdjustMonoSyn',false); % after CellExplorar

        
    end 
end


%%

candidate_ind = collision_metrics.candidate_int_pyr_pairs;

rand_value= collision_metrics.uLEDResponses_RandInterval.maxRatePulse;
rand_value_avarage = mean(rand_value,2);

rand_diff =[collision_metrics.uLEDResponses_OutInterval.maxRatePulse(candidate_ind)- rand_value_avarage(candidate_ind)];
real_value = collision_metrics.rate_difference(candidate_ind);


% HISTOGRAM OF ALL PAIRS 
% Data

nBin = 20;
Y_real= real_value;
edgesY_real = linspace(min(Y_real), max(Y_real), nBin+1); 
[counts_Y_real, edges] = histcounts(Y_real, edgesY_real);

nBin = 20;

Y_rand = rand_diff;
edgesY_rand = linspace(min(Y_rand), max(Y_rand), nBin+1); 
[counts_Y_rand, edges] = histcounts(Y_rand, edgesY_rand);

% figure with log10
figure
hold on
bar(edgesY_real(1:end-1), log10(counts_Y_real),'FaceColor',[0 0 0],'EdgeColor','none','BarWidth',1); 
bar(edgesY_rand(1:end-1), log10(counts_Y_rand),'FaceColor','flat','EdgeColor','none','BarWidth',1); 

xlabel('Rate change difference [Hz]');
ylabel('counts');
set(gca,'TickDir','out');


% figure no log10
figure
hold on
bar(edgesY_real(1:end-1), (counts_Y_real),'FaceColor',[0 0 0],'EdgeColor','none','BarWidth',1); 
bar(edgesY_rand(1:end-1),(counts_Y_rand),'FaceColor','flat','EdgeColor','none','BarWidth',1); 

xlabel('Rate change difference [Hz]');
ylabel('counts');
set(gca,'TickDir','out');

% xlim([0;inf])

% NOISE

candidate_ind = collision_metrics.candidate_int_pyr_pairs;
rand_value= collision_metrics.uLEDResponses_RandInterval.maxRatePulse;

means_tot = [];
std_tot = [];

for ii = 1: size(real_value,1)
    if candidate_ind(ii) == 1
        Y_rand = collision_metrics.uLEDResponses_OutInterval.maxRatePulse(ii)-rand_value(ii,:);
        av_rand = mean(Y_rand);
        sigma = std(Y_rand);
        means_tot = [means_tot; av_rand];
        std_tot = [std_tot; sigma];
    end
end

noise_media = median(means_tot(~isnan(means_tot)));
noise_std = median(std_tot(~isnan(std_tot)))*3;

% pdf of noise 
figure
x = linspace(-5, 5, 1000);
y = (6/(noise_std * sqrt(2*pi))) * exp(-(x - noise_media).^2 / (2*noise_std^2));

figure
hold on
bar(edgesY_real(1:end-1), log10(counts_Y_real),'FaceColor',[0 0 0],'EdgeColor','none','BarWidth',1); 
plot(x, rescale(log10(y),0,2), 'LineWidth', 2);

% DATAS

real_value = collision_metrics.rate_difference(candidate_ind);

% pdf gaussian - does not fit..
real_media = mean(real_value(~isnan(real_value)));
real_std = (std(~isnan(real_value)));
y2 = (6/(real_std * sqrt(2*pi))) * exp(-(x - real_media).^2 / (2*real_std^2));

% disrtibution of 
pd = fitdist(real_value, 'tLocationScale'); 
xgrid = linspace(min(real_value), max(real_value), 100);
yfit = pdf(pd, xgrid);

figure
hold on
histogram(real_value, 'Normalization', 'pdf')
plot(xgrid, log10(yfit*10), 'r-', 'LineWidth', 2)
hold off

figure
plot(log10(yfit*10))

bar(edgesY_real(1:end-1), log10(counts_Y_real),'FaceColor',[0 0 0],'EdgeColor','none','BarWidth',1); 


figure




%% figure of the distribution 

figure

%%
pd = fitdist(x, 'Normal');  % fit con distribuzione normale

% visualizzazione
histogram(x, 'Normalization', 'pdf')
hold on
xgrid = linspace(min(x), max(x), 100);
yfit = pdf(pd, xgrid);
plot(xgrid, yfit, 'r-', 'LineWidth', 2)
hold off


